% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calib_area.R
\name{calib_area}
\alias{calib_area}
\title{Delimit calibration area for ecological niche models}
\usage{
calib_area(data, x, y, method, groups = NULL, crs = NULL)
}
\arguments{
\item{data}{data.frame or tibble. Database with presences}

\item{x}{character. Column name with longitude data}

\item{y}{character. Column name with latitude data}

\item{method}{character. Pseudo-absence allocation method. Could be necessary concatenate (c()) different objects for this argument. The next methods are implemented:
\itemize{
\item buffer: calibration area is defined by a buffer around presences. Usage method = c('buffer', width=40000).
\item mcp: calibration area is defined by a minimum convex polygon. Usage method = 'mcp'.
\item bmcp: calibration area is defined by buffed minimum convex polygon. Usage method = c('bmcp', width=40000).
\item mask: calibration area is defined by those polygons intersected by presences. Usage method = c("mask", clusters, "DN"). The second element concatenated must be a SpatialPolygonDataFrame,  the third element is a character with the column name from SpatialPolygonDataFrame used for filtering polygons.
}}

\item{groups}{character. Column name with that differentiate set of points. This could be used with mcp and bmcp method. Default NULL}

\item{crs}{character. Coordinate reference system used for transforming occurrences and outputs. In case it is set as NULL, crs of result will be NA for buffer, mcp, and bmcp methods. For mask method, the result will have the same crs as SpatialPolygonDataFrame used}
}
\value{
A SpatialPolygon or SpatialPolygonDataFrame
}
\description{
This function offers different methods to define de calibration area. The output could be used with other flexsdm functions like sample_backgroud, sample_pseudoabs, enm_predict, and enm_ensemble, among others
}
\examples{
\dontrun{
require(terra)
require(dplyr)
data("spp")
clusters <- system.file("external/clusters.shp", package = "flexsdm")
clusters <- terra::vect(clusters)

single_spp <-
  spp \%>\%
  dplyr::filter(species == "sp1") \%>\%
  dplyr::filter(pr_ab == 1) \%>\%
  dplyr::select(-pr_ab)


# buffer method
ca_1 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = c("buffer", width = 40000),
)
plot(ca_1)
points(single_spp[, 2:3], pch = 19, cex = 0.5)

# mcp method
ca_2 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = "mcp"
)
plot(ca_2)
points(single_spp[, 2:3], pch = 19, cex = 0.5)

# mcp method for different groups
single_spp <- single_spp \%>\% mutate(groups = ifelse(x > 150000, "a", "b"))

plot(single_spp[, 2:3], pch = 19, col = 'blue')
points(single_spp[single_spp$groups == "a", 2:3], col = "red", pch = 19)
points(single_spp[, 2:3])

ca_2.1 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = c("mcp"),
  groups = "groups"
)
plot(ca_2.1)
points(single_spp[, 2:3], pch = 19, cex = 0.5)

# bmcp method
ca_3 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = c("bmcp", width = 30000)
)
plot(ca_3)
points(single_spp[, 2:3], pch = 19, cex = 0.5)

# bmcp method for different groups
ca_3.1 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = c("bmcp", width = 30000),
  groups = "groups"
)
plot(ca_3.1)
points(single_spp[, 2:3], pch = 19, cex = 0.5)

# mask method
plot(clusters)
names(clusters)

ca_3.1 <- calib_area(
  data = single_spp,
  x = "x",
  y = "y",
  method = c("mask", clusters, "clusters"),
)
plot(ca_3.1)
points(single_spp[, 2:3], pch = 19, cex = 0.5, col = "red")
}
}
