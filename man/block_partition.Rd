% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/block_partition.R
\name{block_partition}
\alias{block_partition}
\title{Spatial block cross validation}
\usage{
block_partition(
  env_layer,
  data,
  x,
  y,
  pr_ab,
  n_part = 2,
  min_res_mult = 3,
  max_res_mult = 200,
  num_grids = 30
)
}
\arguments{
\item{env_layer}{raster. Raster stack or brick with environmental variable. This will be used to evaluate spatial autocorrelation and environmental similarity between training and testing partition}

\item{data}{data.frame. Data.frame or tibble object with presences (or presence-absence, o presences-pseudo-absence) records, and coordinates}

\item{x}{character. Column name with longitude data}

\item{y}{character. Column name with longitude data}

\item{pr_ab}{character. Column with presences, presence-absence, or pseudo-absence. Presences must be represented by 1 and absences by 0}

\item{n_part}{}

\item{min_res_mult}{numeric. Minimum value used for multiplying raster resolution and will define the coarsest resolution to be tested, default 2.}

\item{max_res_mult}{numeric. Maximum value used for multiplying raster resolution and will define the coarsest resolution to be tested, default 50.}

\item{num_grids}{numeric. Number of grid to be tested between 2x(raster resolution) and max_res_mult*(raster resolution), default 30}
}
\value{

}
\description{
Spatial block cross validation
}
\examples{
\dontrun{
data(spp)
data(somevar)

# Lest practice with a single species
single_spp <- spp \%>\% dplyr::filter(species == "sp3")
part <- block_partition(
  env_layer = somevar,
  data = single_spp,
  x = "x",
  y = "y",
  pr_ab = "pr_ab",
  min_res_mult = 10,
  max_res_mult = 500,
  num_grids = 30,
  n_part = 2
)
part

part$ResultList
part$BestGridInfo
part$Grid

# Lets explore Grid object
plot(part$Grid)
points(part$ResultList[c("x", "y")],
  col = c("blue", "red")[part$ResultList$.part],
  cex = 0.5,
  pch = 19
)

raster::res(part$Grid)
raster::res(somevar)

# Note that is a layer with block partition, but it has a different resolution than the original environmental variables.
# In the case you wish have a layer with the same properties (i.e. resolution, extent, NAs) than your original environmental variables you can use the \code{\link{get_block}} function.

grid_env <- get_block(env_layer = somevar, bestgrid = part$Grid)

plot(grid_env) # this is a block layer with the same layer properties than environmental variables.
points(part$ResultList[c("x", "y")],
  col = c("blue", "red")[part$ResultList$.part],
  cex = 0.5,
  pch = 19
)
# This layer could be very useful in case you need sample pseudo_absence or background point
# See examples in \code{\link{get_block}} and \code{\link{get_block}}



# Now lets learn use these functions with several species
spp2 <- split(spp, spp$species)
class(spp2)
length(spp2)
names(spp2)

part_list <- lapply(spp2, function(x) {
  result <- block_partition(
    env_layer = somevar,
    data = x,
    x = "x",
    y = "y",
    pr_ab = "pr_ab",
    min_res_mult = 10,
    max_res_mult = 500,
    num_grids = 30,
    n_part = 2
  )
  result
})

# Lets reconstruct a single database for all species
occ_part <- dplyr::bind_rows(lapply(part_list, function(x) x[[1]]), .id = "species")
occ_part

# Lets get a the best grid info for all species
grid_info <- dplyr::bind_rows(lapply(part_list, function(x) x[[2]]), .id = "species")

# Lets get a the best grid layer for all species
grid_layer <- lapply(part_list, function(x) x[[3]])
sapply(grid_layer, plot)

# Lets get a the best grid info for all species
grid_layer2 <-
  lapply(grid_layer, function(x) {
    get_block(env_layer = somevar[[1]], bestgrid = x)
  })
grid_layer2 <- stack(grid_layer2)
grid_layer2
plot(grid_layer2)


# Block partition for presences-only database
single_spp <- spp \%>\% dplyr::filter(species == "sp2", pr_ab == 1)
single_spp
single_spp$pr_ab \%>\% unique() # only presences

part <- block_partition(
  env_layer = somevar,
  data = single_spp,
  x = "x",
  y = "y",
  pr_ab = "pr_ab",
  min_res_mult = 10,
  max_res_mult = 500,
  num_grids = 30,
  n_part = 2
)

part$ResultList
part$BestGridInfo
part$Grid

plot(part$Grid)
points(
  part$ResultList[c("x", "y")],
  col = c("blue", "red")[part$ResultList$.part],
  cex = 0.5,
  pch = 19
)
}

}
