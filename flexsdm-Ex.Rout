
R version 4.1.0 (2021-05-18) -- "Camp Pontanezen"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R es un software libre y viene sin GARANTIA ALGUNA.
Usted puede redistribuirlo bajo ciertas circunstancias.
Escriba 'license()' o 'licence()' para detalles de distribucion.

R es un proyecto colaborativo con muchos contribuyentes.
Escriba 'contributors()' para obtener más información y
'citation()' para saber cómo citar R o paquetes de R en publicaciones.

Escriba 'demo()' para demostraciones, 'help()' para el sistema on-line de ayuda,
o 'help.start()' para abrir el sistema de ayuda HTML con su navegador.
Escriba 'q()' para salir de R.

> pkgname <- "flexsdm"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('flexsdm')
Warning: replacing previous import 'kernlab::predict' by 'stats::predict' when loading 'flexsdm'
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("calib_area")
> ### * calib_area
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: calib_area
> ### Title: Delimit calibration area for constructing species distribution
> ###   models
> ### Aliases: calib_area
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D require(dplyr)
> ##D data("spp")
> ##D clusters <- system.file("external/clusters.shp", package = "flexsdm")
> ##D clusters <- terra::vect(clusters)
> ##D 
> ##D single_spp <-
> ##D   spp %>%
> ##D   dplyr::filter(species == "sp1") %>%
> ##D   dplyr::filter(pr_ab == 1) %>%
> ##D   dplyr::select(-pr_ab)
> ##D 
> ##D 
> ##D # buffer method
> ##D ca_1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("buffer", width = 40000),
> ##D )
> ##D plot(ca_1)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5)
> ##D 
> ##D # mcp method
> ##D ca_2 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = "mcp"
> ##D )
> ##D plot(ca_2)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5)
> ##D 
> ##D # mcp method for different groups
> ##D single_spp <- single_spp %>% mutate(groups = ifelse(x > 150000, "a", "b"))
> ##D 
> ##D plot(single_spp[, 2:3], pch = 19, col = "blue")
> ##D points(single_spp[single_spp$groups == "a", 2:3], col = "red", pch = 19)
> ##D points(single_spp[, 2:3])
> ##D 
> ##D ca_2.1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("mcp"),
> ##D   groups = "groups"
> ##D )
> ##D plot(ca_2.1)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5)
> ##D 
> ##D # bmcp method
> ##D ca_3 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("bmcp", width = 30000)
> ##D )
> ##D plot(ca_3)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5)
> ##D 
> ##D # bmcp method for different groups
> ##D ca_3.1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("bmcp", width = 30000),
> ##D   groups = "groups"
> ##D )
> ##D plot(ca_3.1)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5)
> ##D 
> ##D # mask method
> ##D plot(clusters)
> ##D names(clusters)
> ##D 
> ##D ca_3.1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("mask", clusters, "clusters"),
> ##D )
> ##D plot(ca_3.1)
> ##D points(single_spp[, 2:3], pch = 19, cex = 0.5, col = "red")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("correct_colinvar")
> ### * correct_colinvar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: correct_colinvar
> ### Title: Perform collinearity reduction on predictors
> ### Aliases: correct_colinvar
> 
> ### ** Examples
> 
> ## Not run: 
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D # Perform pearson collinearity control
> ##D var <- correct_colinvar(env_layer = somevar, method = c("pearson", th = "0.8"))
> ##D var$env_layer
> ##D var$removed_variables
> ##D var$correlation_table
> ##D 
> ##D # Perform vif collinearity control
> ##D var <- correct_colinvar(env_layer = somevar, method = c("vif", th = "8"))
> ##D var$env_layer
> ##D var$removed_variables
> ##D var$correlation_table
> ##D 
> ##D # Perform pca collinearity control
> ##D var <- correct_colinvar(env_layer = somevar, method = c("pca"))
> ##D plot(var$env_layer)
> ##D var$env_layer
> ##D var$coefficient
> ##D var$cumulative_variance
> ##D 
> ##D # Perform fa colinearity control
> ##D # this method only will be performed if covariance matrix is invertible.
> ##D # WRITE HERE A EXAMPLE THAT WORKS :)
> ##D # var <- correct_colinvar(env_layer = somevar, method = c("fa"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("env_outliers")
> ### * env_outliers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: env_outliers
> ### Title: Integration of outliers detection methods in the environmental
> ###   space
> ### Aliases: env_outliers
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D require(terra)
> ##D require(ggplot2)
> ##D 
> ##D # Envirnomental variables
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D # Species occurrences
> ##D data("spp")
> ##D spp
> ##D spp1 <- spp %>% dplyr::filter(species == "sp1")
> ##D 
> ##D somevar[[1]] %>% plot()
> ##D points(spp1 %>% filter(pr_ab == 1) %>% select(x, y), col = "blue", pch = 19)
> ##D points(spp1 %>% filter(pr_ab == 0) %>% select(x, y), col = "red", cex = 0.5)
> ##D 
> ##D spp1 <- spp1 %>% mutate(idd = 1:nrow(spp1))
> ##D 
> ##D # Detect outliers
> ##D outs_1 <- env_outliers(
> ##D   data = spp1,
> ##D   pr_ab = "pr_ab",
> ##D   x = "x",
> ##D   y = "y",
> ##D   id = "idd",
> ##D   env_layer = somevar
> ##D )
> ##D 
> ##D # How many outliers were detected by different methods?
> ##D out_pa <- outs_1 %>%
> ##D   dplyr::select(starts_with("."), -.out_sum) %>%
> ##D   apply(., 2, function(x) sum(x, na.rm = T))
> ##D out_pa
> ##D 
> ##D # How many outliers were detected by the sum of different methods?
> ##D outs_1 %>%
> ##D   dplyr::group_by(.out_sum) %>%
> ##D   dplyr::count()
> ##D 
> ##D # Let explor where are locate records highlighted as outliers
> ##D outs_1 %>%
> ##D   dplyr::filter(pr_ab == 1, .out_sum > 0) %>%
> ##D   ggplot(aes(x, y)) +
> ##D   geom_point(aes(col = factor(.out_sum))) +
> ##D   facet_wrap(. ~ factor(.out_sum))
> ##D 
> ##D # Detect outliers only with presences
> ##D outs_2 <- env_outliers(
> ##D   data = spp1 %>% dplyr::filter(pr_ab == 1),
> ##D   pr_ab = "pr_ab",
> ##D   x = "x",
> ##D   y = "y",
> ##D   id = "idd",
> ##D   env_layer = somevar
> ##D )
> ##D 
> ##D # How many outliers were detected by different methods
> ##D out_p <- outs_2 %>%
> ##D   dplyr::select(starts_with("."), -.out_sum) %>%
> ##D   apply(., 2, function(x) sum(x, na.rm = T))
> ##D 
> ##D # How many outliers were detected by the sum of different methods?
> ##D outs_2 %>%
> ##D   dplyr::group_by(.out_sum) %>%
> ##D   dplyr::count()
> ##D 
> ##D # Let explor where are locate records highlighted as outliers
> ##D outs_2 %>%
> ##D   dplyr::filter(pr_ab == 1, .out_sum > 0) %>%
> ##D   ggplot(aes(x, y)) +
> ##D   geom_point(aes(col = factor(.out_sum))) +
> ##D   facet_wrap(. ~ factor(.out_sum))
> ##D 
> ##D 
> ##D # Comparison of function outputs when using it with
> ##D # presences-absences or only presences data.
> ##D 
> ##D bind_rows(out_p, out_pa)
> ##D # Because the second case only were used presences, outliers methods
> ##D # based in Random Forest (.out_rf) and Support Vector Machines (.out_svm)
> ##D # were not performed.
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_gam")
> ### * esm_gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_gam
> ### Title: Fit and validate Generalized Additive Models based Ensemble of
> ###   Small of Model approach
> ### Aliases: esm_gam
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 3)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_gam_t1 <- esm_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D 
> ##D esm_gam_t1$esm_model # bivariate model
> ##D esm_gam_t1$predictors
> ##D esm_gam_t1$performance
> ##D 
> ##D # Test with rep_kfold partition
> ##D abies_db2 <- abies_db2 %>% select(-starts_with("."))
> ##D 
> ##D set.seed(10)
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D esm_gam_t2 <- esm_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D esm_gam_t2$esm_model # bivariate model
> ##D esm_gam_t2$predictors
> ##D esm_gam_t2$performance
> ##D 
> ##D # Test with other bootstrap
> ##D abies_db2 <- abies_db2 %>% select(-starts_with("."))
> ##D 
> ##D set.seed(10)
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 10, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D esm_gam_t3 <- esm_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D esm_gam_t3$esm_model # bivariate model
> ##D esm_gam_t3$predictors
> ##D esm_gam_t3$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_gau")
> ### * esm_gau
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_gau
> ### Title: Fit and validate Gaussian Process models based Ensemble of Small
> ###   of Model approach
> ### Aliases: esm_gau
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_gau_t1 <- esm_gau(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL,
> ##D   background = NULL,
> ##D   clamp = TRUE,
> ##D   classes = "default",
> ##D   pred_type = "cloglog",
> ##D   regmult = 1
> ##D )
> ##D 
> ##D esm_gau_t1$esm_model # bivariate model
> ##D esm_gau_t1$predictors
> ##D esm_gau_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_gbm")
> ### * esm_gbm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_gbm
> ### Title: Fit and validate Generalized Boosted Regression models based
> ###   Ensemble of Small of Model approach
> ### Aliases: esm_gbm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_gbm_t1 <- esm_gbm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL,
> ##D   n_trees = 100,
> ##D   n_minobsinnode = as.integer(nrow(data) * 0.5 / 4),
> ##D   shrinkage = 0.1
> ##D )
> ##D 
> ##D esm_gbm_t1$esm_model # bivariate model
> ##D esm_gbm_t1$predictors
> ##D esm_gbm_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_glm")
> ### * esm_glm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_glm
> ### Title: Fit and validate Generalized Linear Models based Ensemble of
> ###   Small of Model approach
> ### Aliases: esm_glm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_glm_t1 <- esm_glm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL,
> ##D   poly = 0,
> ##D   inter_order = 0
> ##D )
> ##D 
> ##D esm_glm_t1$esm_model # bivariate model
> ##D esm_glm_t1$predictors
> ##D esm_glm_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_max")
> ### * esm_max
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_max
> ### Title: Fit and validate Generalized Additive Models based Ensemble of
> ###   Small of Model approach
> ### Aliases: esm_max
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D data("backg")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D set.seed(10)
> ##D backg2 <- backg %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 100) %>%
> ##D   group_by()
> ##D 
> ##D backg2 <- part_random(
> ##D   data = backg2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D backg2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_max_t1 <- esm_max(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL,
> ##D   background = backg2,
> ##D   clamp = TRUE,
> ##D   classes = "default",
> ##D   pred_type = "cloglog",
> ##D   regmult = 1
> ##D )
> ##D 
> ##D esm_max_t1$esm_model # bivariate model
> ##D esm_max_t1$predictors
> ##D esm_max_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_net")
> ### * esm_net
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_net
> ### Title: Fit and validate Neural Networks based Ensemble of Small of
> ###   Model approach
> ### Aliases: esm_net
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_net_t1 <- esm_net(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "cwd", "tmin", "ppt_djf", "ppt_jja", "pH", "awc", "depth", "percent_clay"),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D 
> ##D esm_net_t1$esm_model # bivariate model
> ##D esm_net_t1$predictors
> ##D esm_net_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("esm_svm")
> ### * esm_svm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: esm_svm
> ### Title: Fit and validate Support Vector Machine models based Ensemble of
> ###   Small of Model approach
> ### Aliases: esm_svm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D require(dplyr)
> ##D 
> ##D # Using k-fold partition method
> ##D set.seed(10)
> ##D abies_db2 <- abies_db %>%
> ##D   na.omit() %>%
> ##D   group_by(pr_ab) %>%
> ##D   dplyr::slice_sample(n = 10) %>%
> ##D   group_by()
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db2,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Without threshold specification and with kfold
> ##D esm_svm_t1 <- esm_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c(
> ##D     "aet", "cwd", "tmin", "ppt_djf", "ppt_jja",
> ##D     "pH", "awc", "depth", "percent_clay"
> ##D   ),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D 
> ##D esm_svm_t1$esm_model # bivariate model
> ##D esm_svm_t1$predictors
> ##D esm_svm_t1$performance
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("extra_correct")
> ### * extra_correct
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extra_correct
> ### Title: Correction of suitability based on extrapolation
> ### Aliases: extra_correct
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # see examples in extra_eval function
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("extra_eval")
> ### * extra_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: extra_eval
> ### Title: Measure model extrapolation
> ### Aliases: extra_eval
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D require(terra)
> ##D 
> ##D data(spp)
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(f)
> ##D 
> ##D spp$species %>% unique()
> ##D sp <- spp %>%
> ##D   dplyr::filter(species == "sp3", pr_ab == 1) %>%
> ##D   dplyr::select(x, y)
> ##D 
> ##D # Accessible area
> ##D ca <- calib_area(sp, x = "x", y = "y", method = c("buffer", width = 30000))
> ##D 
> ##D plot(somevar$CFP_1)
> ##D points(sp)
> ##D plot(ca, add = T)
> ##D 
> ##D # Get environmental condition of calibration area
> ##D somevar_ca <- somevar %>%
> ##D   crop(., ca) %>%
> ##D   mask(., ca)
> ##D plot(somevar_ca)
> ##D 
> ##D xp <-
> ##D   extra_eval(
> ##D     env_calib = somevar_ca,
> ##D     env_proj = somevar,
> ##D     n_cores = 1,
> ##D     aggreg_factor = 3
> ##D   )
> ##D plot(xp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fit_ensemble")
> ### * fit_ensemble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_ensemble
> ### Title: Model assemble and validation
> ### Aliases: fit_ensemble
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Fit some models
> ##D mglm <- fit_glm(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part",
> ##D   poly = 2
> ##D )
> ##D mraf <- fit_raf(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part",
> ##D )
> ##D mgbm <- fit_gbm(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part"
> ##D )
> ##D 
> ##D # Fit and ensemble
> ##D mensemble <- fit_ensemble(
> ##D   models = list(mglm, mraf, mgbm),
> ##D   ens_method = "meansup",
> ##D   thr = NULL,
> ##D   thr_model = "max_sens_spec",
> ##D   metric = "TSS"
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fit_gam")
> ### * fit_gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_gam
> ### Title: Fit and validate Generalized Additive Models
> ### Aliases: fit_gam
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D gam_t1 <- fit_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = "max_sens_spec"
> ##D )
> ##D gam_t1$model
> ##D gam_t1$predictors
> ##D gam_t1$performance
> ##D 
> ##D # Using our own formula
> ##D require(gam)
> ##D gam_t2 <- fit_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = "max_sens_spec",
> ##D   fit_formula = stats::formula(pr_ab ~ s(aet, df = 4) +
> ##D     s(ppt_jja, df = 3) +
> ##D     s(pH, df = 3) + landform)
> ##D )
> ##D 
> ##D gam_t2$model
> ##D gam_t2$predictors
> ##D gam_t2$performance %>% dplyr::select(ends_with("_mean"))
> ##D 
> ##D # Using repeated k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 5, replicates = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D gam_t3 <- fit_gam(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("ppt_jja", "pH", "awc"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = "max_sens_spec"
> ##D )
> ##D gam_t3
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_gau")
> ### * fit_gau
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_gau
> ### Title: Fit and validate Gaussian Process models
> ### Aliases: fit_gau
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 3)
> ##D )
> ##D abies_db2
> ##D 
> ##D bg <- abies_db2
> ##D bg$pr_ab <- 0
> ##D 
> ##D 
> ##D gaup_t1 <- fit_gau(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   background = bg,
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen")
> ##D )
> ##D 
> ##D gaup_t1$model
> ##D gaup_t1$predictors
> ##D gaup_t1$performance
> ##D gaup_t1$data_ens
> ##D 
> ##D # Using bootstrap partition method and only with presence-absence
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 5, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D gaup_t2 <- fit_gau(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("ppt_jja", "pH", "awc"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c(type = c("lpt", "max_sens_spec", "sensitivity"), sens = "0.8")
> ##D )
> ##D gaup_t2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_gbm")
> ### * fit_gbm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_gbm
> ### Title: Fit and validate Generalized Boosted Regression models
> ### Aliases: fit_gbm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D gbm_t1 <- fit_gbm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen")
> ##D )
> ##D gbm_t1$model
> ##D gbm_t1$performance
> ##D gbm_t1$selected_thresholds
> ##D gbm_t1$all_thresholds
> ##D 
> ##D # Using bootstrap partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 10, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D gbm_t2 <- fit_gbm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("ppt_jja", "pH", "awc"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = "max_sens_spec"
> ##D )
> ##D gbm_t2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_glm")
> ### * fit_glm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_glm
> ### Title: Fit and validate Generalized Linear Models
> ### Aliases: fit_glm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D abies_db
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D glm_t1 <- fit_glm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   poly = 0,
> ##D   inter_order = 0
> ##D )
> ##D glm_t1$model
> ##D glm_t1$predictors
> ##D glm_t1$performance
> ##D glm_t1$data_ens
> ##D 
> ##D 
> ##D glm_t2 <- fit_glm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   poly = 2,
> ##D   inter_order = 1
> ##D )
> ##D 
> ##D # Using repeated k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 10, replicates = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D glm_t3 <- fit_glm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("ppt_jja", "pH", "awc"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   poly = 3,
> ##D   inter_order = 2
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_max")
> ### * fit_max
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_max
> ### Title: Fit and validate Maximum Entropy models
> ### Aliases: fit_max
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D data("backg")
> ##D abies_db # environmental conditions of presence-absence data
> ##D backg # environmental conditions of background points
> ##D 
> ##D # Using k-fold partition method
> ##D # Remember that the partition method, number of folds or replications must
> ##D # be the same for presence-absence and background points datasets
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D abies_db2
> ##D 
> ##D backg2 <- part_random(
> ##D   data = backg,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D backg2
> ##D 
> ##D max_t1 <- fit_max(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   background = backg2,
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   clamp = TRUE,
> ##D   classes = "default",
> ##D   pred_type = "cloglog",
> ##D   regmult = 1
> ##D )
> ##D length(max_t1)
> ##D max_t1$model
> ##D max_t1$predictors
> ##D max_t1$performance
> ##D max_t1$data_ens
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_net")
> ### * fit_net
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_net
> ### Title: Fit and validate Neural Networks models
> ### Aliases: fit_net
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D nnet_t1 <- fit_net(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   fit_formula = NULL
> ##D )
> ##D 
> ##D nnet_t1$model
> ##D nnet_t1$performance
> ##D nnet_t1$selected_thresholds
> ##D nnet_t1$all_thresholds
> ##D 
> ##D # Using bootstrap partition method and only with presence-absence
> ##D # and get performance for several method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 10, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D nnet_t2 <- fit_net(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   fit_formula = NULL
> ##D )
> ##D nnet_t2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_raf")
> ### * fit_raf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_raf
> ### Title: Fit and validate Random Forest models
> ### Aliases: fit_raf
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D rf_t1 <- fit_raf(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("MAX_TSS", "EQUAL_SENS_SPEC", "MAX_SORENSEN"),
> ##D   fit_formula = NULL
> ##D )
> ##D 
> ##D rf_t1$model
> ##D rf_t1$performance
> ##D rf_t1$selected_thresholds
> ##D rf_t1$all_thresholds
> ##D 
> ##D # Using bootstrap partition method and only with presence-absence
> ##D # and get performance for several method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 10, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D rf_t2 <- fit_raf(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   fit_formula = NULL
> ##D )
> ##D rf_t2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_svm")
> ### * fit_svm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_svm
> ### Title: Fit and validate Support Vector Machine models
> ### Aliases: fit_svm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D 
> ##D # Using k-fold partition method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D svm_t1 <- fit_svm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   fit_formula = NULL
> ##D )
> ##D 
> ##D svm_t1$model
> ##D svm_t1$performance
> ##D svm_t1$selected_thresholds
> ##D svm_t1$all_thresholds
> ##D 
> ##D # Using bootstrap partition method and only with presence-absence
> ##D # and get performance for several method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 10, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D 
> ##D svm_t2 <- fit_svm(
> ##D   data = abies_db2,
> ##D   response = "pr_ab",
> ##D   predictors = c("aet", "ppt_jja", "pH", "awc", "depth"),
> ##D   predictors_f = c("landform"),
> ##D   partition = ".part",
> ##D   thr = c("max_sens_spec", "equal_sens_spec", "mas_sorensen"),
> ##D   fit_formula = NULL
> ##D )
> ##D svm_t2
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("get_block")
> ### * get_block
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_block
> ### Title: Transform a spatial partition layer to the same spatial
> ###   properties of environmental variables
> ### Aliases: get_block
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D require(terra)
> ##D data(spp)
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(f)
> ##D 
> ##D # Lest practice with a single species
> ##D single_spp <- spp %>% dplyr::filter(species == "sp3")
> ##D 
> ##D part <- part_sblock(
> ##D   env_layer = somevar,
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_res_mult = 100,
> ##D   max_res_mult = 500,
> ##D   num_grids = 10,
> ##D   n_part = 2
> ##D )
> ##D 
> ##D grid_env <- get_block(env_layer = somevar, best_grid = part$grid)
> ##D grid_env
> ##D part$grid
> ##D 
> ##D plot(part$grid)
> ##D plot(grid_env)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("homogenize_na")
> ### * homogenize_na
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: homogenize_na
> ### Title: Homogenize cells with NAs across all layers
> ### Aliases: homogenize_na
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #' require(terra)
> ##D 
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D somevar2 <- homogenize_na(somevar)
> ##D par(mfrow = c(2, 1))
> ##D plot(somevar$CFP_4)
> ##D plot(somevar2$CFP_4)
> ##D par(mfrow = c(1, 1))
> ##D 
> ##D # In somevar2 all layers have the same cells with NAs
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("inter")
> ### * inter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inter
> ### Title: Raster interpolation between two time periods
> ### Aliases: inter
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D require(dplyr)
> ##D 
> ##D f <- system.file("external/suit_time_steps.tif", package = "flexsdm")
> ##D abma <- terra::rast(f)
> ##D plot(abma)
> ##D 
> ##D int <- inter(
> ##D   r1 = abma[[1]],
> ##D   r2 = abma[[2]],
> ##D   y1 = 2010,
> ##D   y2 = 2020,
> ##D   rastername = "Abies",
> ##D   dir_save = NULL,
> ##D   n_cores = 1
> ##D )
> ##D 
> ##D int
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("occfilt_env")
> ### * occfilt_env
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: occfilt_env
> ### Title: Perform environmental filtering on species occurrences
> ### Aliases: occfilt_env
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D require(dplyr)
> ##D 
> ##D # Envirnomental variables
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D plot(somevar)
> ##D 
> ##D # Species occurrences
> ##D data("spp")
> ##D spp
> ##D spp1 <- spp %>% dplyr::filter(species == "sp1", pr_ab == 1)
> ##D 
> ##D somevar[[1]] %>% plot()
> ##D points(spp1 %>% select(x, y))
> ##D 
> ##D spp1$idd <- 1:nrow(spp1)
> ##D 
> ##D 
> ##D # 5 bins
> ##D filtered_1 <- env_filtering(
> ##D   data = spp1,
> ##D   x = "x",
> ##D   y = "y",
> ##D   id = "idd",
> ##D   env_layer = somevar,
> ##D   nbins = 5,
> ##D   cores = 1
> ##D )
> ##D 
> ##D # 8 bins
> ##D filtered_2 <- env_filtering(
> ##D   data = spp1,
> ##D   x = "x",
> ##D   y = "y",
> ##D   id = "idd",
> ##D   env_layer = somevar,
> ##D   nbins = 8,
> ##D   cores = 1
> ##D )
> ##D 
> ##D # 12 bins
> ##D filtered_3 <- env_filtering(
> ##D   data = spp1,
> ##D   x = "x",
> ##D   y = "y",
> ##D   id = "idd",
> ##D   env_layer = somevar,
> ##D   nbins = 12,
> ##D   cores = 1
> ##D )
> ##D # note that while higher the nbins parameter higher the number of
> ##D # classes to be processed (4 variables, 30 bins = 923521 classes)
> ##D 
> ##D # While higher the number of bins smaller the number of records retained
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("part_random")
> ### * part_random
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: part_random
> ### Title: Conventional data partitioning methods
> ### Aliases: part_random
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("abies_db")
> ##D abies_db$partition <- NULL
> ##D abies_db <- tibble(abies_db)
> ##D 
> ##D # K-fold method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Repeated K-fold method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 10, replicates = 10)
> ##D )
> ##D abies_db2
> ##D 
> ##D # Leave-one-out cross-validation (loocv) method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "loocv")
> ##D )
> ##D abies_db2
> ##D 
> ##D # Bootstrap method
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "boot", replicates = 50, proportion = 0.7)
> ##D )
> ##D abies_db2
> ##D abies_db2$.part1 %>% table() # Note that for this method .partX columns have train and test words.
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("part_sblock")
> ### * part_sblock
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: part_sblock
> ### Title: Spatial block cross-validation
> ### Aliases: part_sblock
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D require(dplyr)
> ##D 
> ##D # Load datasets
> ##D data(spp)
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(f)
> ##D 
> ##D # Lest practice with a single species
> ##D single_spp <- spp %>% dplyr::filter(species == "sp3")
> ##D part <- part_sblock(
> ##D   env_layer = somevar,
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_res_mult = 10,
> ##D   max_res_mult = 500,
> ##D   num_grids = 30,
> ##D   n_part = 2,
> ##D   prop = 0.5
> ##D )
> ##D part
> ##D 
> ##D part$part
> ##D part$best_part_info
> ##D part$grid
> ##D 
> ##D # Lets explore Grid object
> ##D 
> ##D plot(part$grid)
> ##D points(part$part[c("x", "y")],
> ##D   col = c("blue", "red")[part$part$.part],
> ##D   cex = 0.5,
> ##D   pch = 19
> ##D )
> ##D 
> ##D terra::res(part$grid)
> ##D terra::res(somevar)
> ##D 
> ##D # Note that is a layer with block partition, but it has a
> ##D # different resolution than the original environmental variables.
> ##D # In the case you wish have a layer with the same properties
> ##D # (i.e. resolution, extent, NAs) than your original environmental
> ##D # variables you can use the \code{get_block} function.
> ##D 
> ##D grid_env <- get_block(env_layer = somevar, best_grid = part$grid)
> ##D 
> ##D plot(grid_env) # this is a block layer with the same layer
> ##D # properties as environmental variables.
> ##D points(part$part[c("x", "y")],
> ##D   col = c("blue", "red")[part$part$.part],
> ##D   cex = 0.5,
> ##D   pch = 19
> ##D )
> ##D # This layer could be very useful in case you need sample
> ##D # pseudo_absence or background point
> ##D # See examples in \code{backgroudp} and \code{pseudoabs}
> ##D 
> ##D 
> ##D # Lest try with a higher number of partition
> ##D part <- part_sblock(
> ##D   env_layer = somevar,
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_res_mult = 10,
> ##D   max_res_mult = 500,
> ##D   num_grids = 30,
> ##D   n_part = 4,
> ##D   prop = 0.5
> ##D )
> ##D 
> ##D # Lets explore Grid object
> ##D plot(part$grid, col = gray.colors(4))
> ##D points(part$part[c("x", "y")],
> ##D   col = rainbow(n = 4)[part$part$.part],
> ##D   cex = 0.5,
> ##D   pch = 19
> ##D )
> ##D 
> ##D 
> ##D # Now lets learn use these functions with several species
> ##D spp2 <- split(spp, spp$species)
> ##D class(spp2)
> ##D length(spp2)
> ##D names(spp2)
> ##D 
> ##D part_list <- lapply(spp2, function(x) {
> ##D   result <- part_sblock(
> ##D     env_layer = somevar,
> ##D     data = x,
> ##D     x = "x",
> ##D     y = "y",
> ##D     pr_ab = "pr_ab",
> ##D     min_res_mult = 10,
> ##D     max_res_mult = 500,
> ##D     num_grids = 30,
> ##D     n_part = 2,
> ##D     prop = 0.5
> ##D   )
> ##D   result
> ##D })
> ##D 
> ##D # Lets create a single database for all species
> ##D occ_part <- dplyr::bind_rows(lapply(
> ##D   part_list,
> ##D   function(x) x[[1]]
> ##D ), .id = "species")
> ##D occ_part
> ##D 
> ##D # Lets get a the best grid info for all species
> ##D grid_info <- dplyr::bind_rows(lapply(
> ##D   part_list,
> ##D   function(x) x[[2]]
> ##D ), .id = "species")
> ##D 
> ##D # Lets get a the best grid layer for all species
> ##D grid_layer <- lapply(part_list, function(x) x$grid)
> ##D grid_layer2 <-
> ##D   lapply(grid_layer, function(x) {
> ##D     get_block(env_layer = somevar[[1]], best_grid = x)
> ##D   })
> ##D grid_layer2 <- terra::rast(grid_layer2)
> ##D grid_layer2
> ##D plot(grid_layer2)
> ##D 
> ##D 
> ##D # Block partition for presences-only database
> ##D single_spp <- spp %>%
> ##D   dplyr::filter(species == "sp2", pr_ab == 1)
> ##D single_spp
> ##D single_spp$pr_ab %>% unique() # only presences
> ##D 
> ##D part <- part_sblock(
> ##D   env_layer = somevar,
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_res_mult = 10,
> ##D   max_res_mult = 500,
> ##D   num_grids = 30,
> ##D   n_part = 2,
> ##D   prop = 0.5
> ##D )
> ##D 
> ##D part$part
> ##D part$best_part_info
> ##D part$grid
> ##D 
> ##D plot(part$grid)
> ##D points(
> ##D   part$part[c("x", "y")],
> ##D   col = c("blue", "red")[part$part$.part],
> ##D   cex = 0.5,
> ##D   pch = 19
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("part_senv")
> ### * part_senv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: part_senv
> ### Title: Environmental and spatial cross-validation
> ### Aliases: part_senv
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D require(ggplot2)
> ##D 
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(f)
> ##D 
> ##D # Select a species
> ##D spp1 <- spp %>% dplyr::filter(species == "sp1")
> ##D 
> ##D part1 <- part_senv(
> ##D   env_layer = somevar,
> ##D   data = spp1,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_n_groups = 2,
> ##D   max_n_groups = 10,
> ##D   prop = 0.2
> ##D )
> ##D 
> ##D part1
> ##D 
> ##D ggplot(part1$part, aes(x, y, col = factor(.part))) +
> ##D   geom_point(aes(shape = factor(pr_ab)))
> ##D 
> ##D ggplot(part1$part, aes(x, y, col = factor(.part))) +
> ##D   geom_point(aes(shape = factor(pr_ab))) +
> ##D   facet_wrap(. ~ .part)
> ##D 
> ##D ggplot(part1$part, aes(x, y, col = factor(.part))) +
> ##D   geom_point(aes(shape = factor(pr_ab))) +
> ##D   facet_wrap(. ~ pr_ab)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot_res")
> ### * plot_res
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_res
> ### Title: Plot different resolutions to be used in part_sblock
> ### Aliases: plot_res
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D r <- terra::rast(f)
> ##D r <- r$CFP_1
> ##D plot_res(r, res_mult = 100)
> ##D plot_res(r, res_mult = 200)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sample_background")
> ### * sample_background
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sample_background
> ### Title: Sample background points
> ### Aliases: sample_background
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D data(spp)
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D # Lest practice with a single species
> ##D single_spp <- spp %>% dplyr::filter(species == "sp3")
> ##D 
> ##D part <- part_sblock(
> ##D   env_layer = somevar,
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   pr_ab = "pr_ab",
> ##D   min_res_mult = 100,
> ##D   max_res_mult = 500,
> ##D   num_grids = 10,
> ##D   n_part = 2
> ##D )
> ##D 
> ##D grid_env <- get_block(env_layer = somevar, best_grid = part$grid)
> ##D plot(grid_env)
> ##D 
> ##D # Sample background points throughout study area
> ##D bg <- sample_background(n = 1000, rlayer = grid_env)
> ##D plot(grid_env)
> ##D points(bg)
> ##D 
> ##D # Sample background points constrained to a region regions with a give set of values
> ##D plot(grid_env)
> ##D sample_background(n = 1000, rlayer = grid_env, maskval = 1) %>% points()
> ##D plot(grid_env)
> ##D sample_background(n = 1000, rlayer = grid_env, maskval = 2) %>% points()
> ##D plot(grid_env)
> ##D sample_background(n = 1000, rlayer = grid_env, maskval = c(1, 2)) %>% points()
> ##D 
> ##D # Sample background within a calibration area and constrained to a region regions
> ##D # Delimit a calibration area with calib_area
> ##D ca_ps1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("buffer", width = 50000),
> ##D )
> ##D plot(grid_env)
> ##D plot(ca_ps1, add = T)
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D sample_background(n = 1000, rlayer = grid_env, maskval = 1, calibarea = ca_ps1) %>%
> ##D   points(col = "red")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sample_pseudoabs")
> ### * sample_pseudoabs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sample_pseudoabs
> ### Title: Pseudo-absence sampling method
> ### Aliases: sample_pseudoabs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data("spp")
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D regions <- system.file("external/regions.tif", package = "flexsdm")
> ##D regions <- terra::rast(regions)
> ##D 
> ##D plot(regions)
> ##D 
> ##D 
> ##D single_spp <-
> ##D   spp %>%
> ##D   dplyr::filter(species == "sp3") %>%
> ##D   dplyr::filter(pr_ab == 1) %>%
> ##D   dplyr::select(-pr_ab)
> ##D 
> ##D 
> ##D # Pseudo-absences randomly sampled throughout study area
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = "rnd",
> ##D     rlayer = regions,
> ##D     maskval = NULL
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19) # presences
> ##D points(ps1, col = "red", cex = 0.7, pch = 19) # absences
> ##D 
> ##D 
> ##D # Pseudo-absences randomly sampled within a regions where a species occurs
> ##D ## Regions where this species occurrs
> ##D samp_here <- terra::extract(regions, single_spp[2:3])[, 2] %>%
> ##D   unique() %>%
> ##D   na.exclude()
> ##D 
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = "rnd",
> ##D     rlayer = regions,
> ##D     maskval = samp_here
> ##D   )
> ##D 
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D 
> ##D 
> ##D # Pseudo-absences sampled with geographical constraint
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = c("geo_const", width = "30000"),
> ##D     rlayer = regions,
> ##D     maskval = samp_here
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D 
> ##D # Pseudo-absences sampled with environmental constraint
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = c("env_const", env = somevar),
> ##D     rlayer = regions,
> ##D     maskval = samp_here
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D 
> ##D # Pseudo-absences sampled with environmental and geographical contraint
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = c("geo_env_const", width = "50000", env = somevar),
> ##D     rlayer = regions,
> ##D     maskval = samp_here
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D 
> ##D # Pseudo-absences sampled with environmental and geographical contraint and with k-mean
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 10,
> ##D     method = c("geo_env_km_const", width = "50000", env = somevar),
> ##D     rlayer = regions,
> ##D     maskval = samp_here
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D 
> ##D # Sampling pseudo-absence using a calibration area
> ##D ca_ps1 <- calib_area(
> ##D   data = single_spp,
> ##D   x = "x",
> ##D   y = "y",
> ##D   method = c("buffer", width = 50000),
> ##D )
> ##D plot(regions, col = gray.colors(9))
> ##D plot(ca_ps1, add = T)
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D 
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 50,
> ##D     method = "rnd",
> ##D     rlayer = regions,
> ##D     maskval = NULL,
> ##D     calibarea = ca_ps1
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D plot(ca_ps1, add = T)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ##D 
> ##D 
> ##D ps1 <-
> ##D   sample_pseudoabs(
> ##D     data = single_spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     n = nrow(single_spp) * 50,
> ##D     method = "rnd",
> ##D     rlayer = regions,
> ##D     maskval = samp_here,
> ##D     calibarea = ca_ps1
> ##D   )
> ##D plot(regions, col = gray.colors(9))
> ##D plot(ca_ps1, add = T)
> ##D points(ps1, col = "red", cex = 0.7, pch = 19)
> ##D points(single_spp[-1], col = "blue", cex = 0.7, pch = 19)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sdm_eval")
> ### * sdm_eval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdm_eval
> ### Title: Calculate different model performance metrics
> ### Aliases: sdm_eval
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D 
> ##D set.seed(0)
> ##D p <- rnorm(50, mean = 0.7, sd = 0.3) %>% abs()
> ##D p[p > 1] <- 1
> ##D p[p < 0] <- 0
> ##D 
> ##D set.seed(0)
> ##D a <- rnorm(50, mean = 0.3, sd = 0.2) %>% abs()
> ##D a[a > 1] <- 1
> ##D a[a < 0] <- 0
> ##D 
> ##D set.seed(0)
> ##D backg <- rnorm(1000, mean = 0.4, sd = 0.4) %>% abs()
> ##D backg[backg > 1] <- 1
> ##D backg[backg < 0] <- 0
> ##D 
> ##D # Function use without threshold specification
> ##D e <- sdm_eval(p, a)
> ##D e
> ##D 
> ##D # Function use with threshold specification
> ##D sdm_eval(p, a, thr = "max_sorensen")
> ##D sdm_eval(p, a, thr = c("lpt", "max_sens_spec", "max_jaccard"))
> ##D sdm_eval(p, a, thr = c("lpt", "max_sens_spec", "sensitivity"))
> ##D sdm_eval(p, a, thr = c("lpt", "max_sens_spec", "sensitivity", sens = "0.95"))
> ##D 
> ##D # Use of bg argument (it will only be used for calculating BOYCE index)
> ##D sdm_eval(p, a, thr = "max_sens_spec")
> ##D sdm_eval(p, a, thr = c("max_sens_spec"), bg = backg)
> ##D 
> ##D # I the case it is needed use background for calculate all other metric
> ##D # background values can be used in "a" argument
> ##D sdm_eval(p, backg, thr = "max_sens_spec")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sdm_extract")
> ### * sdm_extract
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdm_extract
> ### Title: Extract environmental data based on x and y coordinates
> ### Aliases: sdm_extract
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(terra)
> ##D 
> ##D # Load datasets
> ##D data(spp)
> ##D f <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(f)
> ##D 
> ##D # Extract environmental data from somevar for all species locations in spp
> ##D ex_spp <-
> ##D   sdm_extract(
> ##D     data = spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     env_layer = somevar,
> ##D     variables = NULL,
> ##D     filter_na = FALSE
> ##D   )
> ##D 
> ##D # Extract environmental for two variables and remove rows with NAs
> ##D ex_spp2 <-
> ##D   sdm_extract(
> ##D     data = spp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     env_layer = somevar,
> ##D     variables = c("CFP_3", "CFP_4"),
> ##D     filter_na = TRUE
> ##D   )
> ##D 
> ##D ex_spp
> ##D ex_spp2
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("sdm_predict")
> ### * sdm_predict
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sdm_predict
> ### Title: Spatial predictions of individual and ensemble models
> ### Aliases: sdm_predict
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(dplyr)
> ##D require(terra)
> ##D 
> ##D data("spp")
> ##D somevar <- system.file("external/somevar.tif", package = "flexsdm")
> ##D somevar <- terra::rast(somevar)
> ##D 
> ##D # Extract data
> ##D some_sp <- spp %>%
> ##D   filter(species == "sp3")
> ##D 
> ##D some_sp <-
> ##D   sdm_extract(
> ##D     data = some_sp,
> ##D     x = "x",
> ##D     y = "y",
> ##D     env_layer = somevar
> ##D   )
> ##D 
> ##D # Partition
> ##D some_sp <- part_random(
> ##D   data = some_sp,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "rep_kfold", folds = 3, replicates = 5)
> ##D )
> ##D 
> ##D 
> ##D ## %######################################################%##
> ##D #                                                          #
> ##D ####          Create different type of models           ####
> ##D #                                                          #
> ##D ## %######################################################%##
> ##D # Fit some models
> ##D mglm <- fit_glm(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part",
> ##D   poly = 2
> ##D )
> ##D mraf <- fit_raf(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part",
> ##D )
> ##D mgbm <- fit_gbm(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part"
> ##D )
> ##D 
> ##D # Fit and ensemble
> ##D mensemble <- fit_ensemble(
> ##D   models = list(mglm, mraf, mgbm),
> ##D   ens_method = "meansup",
> ##D   thr = NULL,
> ##D   thr_model = "max_sens_spec",
> ##D   metric = "TSS"
> ##D )
> ##D 
> ##D # Fit a model with a Wnsemble of Small Models approach
> ##D # Without threshold specification and with kfold
> ##D msmall <- esm_gam(
> ##D   data = some_sp,
> ##D   response = "pr_ab",
> ##D   predictors = c("CFP_1", "CFP_2", "CFP_3", "CFP_4"),
> ##D   partition = ".part",
> ##D   thr = NULL
> ##D )
> ##D 
> ##D 
> ##D ## %######################################################%##
> ##D #                                                          #
> ##D ####      Predict different kind of models models       ####
> ##D #                                                          #
> ##D ## %######################################################%##
> ##D 
> ##D # sdm_predict can be used for predict one or more models fitted with fit_ or tune_ functions
> ##D 
> ##D # a single model
> ##D ind_p <- sdm_predict(
> ##D   models = mglm,
> ##D   pred = somevar,
> ##D   thr = "max_fpb",
> ##D   con_thr = FALSE,
> ##D   predict_area = NULL
> ##D )
> ##D 
> ##D # a list of models
> ##D list_p <- sdm_predict(
> ##D   models = list(mglm, mraf, mgbm),
> ##D   pred = somevar,
> ##D   thr = "max_fpb",
> ##D   con_thr = FALSE,
> ##D   predict_area = NULL
> ##D )
> ##D 
> ##D # Predict an ensemble model
> ##D # (only is possilbe use one fit_ensemble)
> ##D ensemble_p <- sdm_predict(
> ##D   models = mensemble,
> ##D   pred = somevar,
> ##D   thr = "max_fpb",
> ##D   con_thr = FALSE,
> ##D   predict_area = NULL
> ##D )
> ##D 
> ##D # Predict an ensemble of small model
> ##D # (only is possilbe use one ensemble of small model)
> ##D small_p <- sdm_predict(
> ##D   models = msmall,
> ##D   pred = somevar,
> ##D   thr = "max_fpb",
> ##D   con_thr = FALSE,
> ##D   predict_area = NULL
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tune_gbm")
> ### * tune_gbm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tune_gbm
> ### Title: Fit and validate Generalized Boosted Regression models with
> ###   exploration of hyper-parameters
> ### Aliases: tune_gbm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(abies_db)
> ##D abies_db
> ##D 
> ##D # We will partition the data with the k-fold method
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D 
> ##D # pr_ab columns is species presence and absences (i.e. the response variable)
> ##D # from aet to landform are the predictors variables (landform is a qualitative variable)
> ##D 
> ##D # Hyper-parameter values for tuning
> ##D tune_grid <-
> ##D   expand.grid(
> ##D     n.trees = c(20, 50, 100),
> ##D     shrinkage = c(0.1, 0.5, 1),
> ##D     n.minobsinnode = c(1, 3, 5, 7, 9)
> ##D   )
> ##D 
> ##D gbm_t <-
> ##D   tune_gbm(
> ##D     data = abies_db2,
> ##D     response = "pr_ab",
> ##D     predictors = c(
> ##D       "aet", "cwd", "tmin", "ppt_djf", "ppt_jja",
> ##D       "ppt_jja", "pH", "awc", "depth", "percent_clay"
> ##D     ),
> ##D     predictors_f = c("landform"),
> ##D     partition = ".part",
> ##D     grid = tune_grid,
> ##D     thr = "max_sens_spec",
> ##D     metric = "TSS"
> ##D   )
> ##D 
> ##D # Outputs
> ##D gbm_t$model
> ##D gbm_t$predictors
> ##D gbm_t$performance
> ##D gbm_t$data_ens
> ##D gbm_t$hyper_performance
> ##D 
> ##D # Graphical exploration of performance of each hyper-parameter setting
> ##D require(ggplot2)
> ##D pg <- position_dodge(width = 0.5)
> ##D ggplot(gbm_t$hyper_performance, aes(factor(n.minobsinnode),
> ##D   TSS_mean,
> ##D   col = factor(shrinkage)
> ##D )) +
> ##D   geom_errorbar(aes(ymin = TSS_mean - TSS_sd, ymax = TSS_mean + TSS_sd),
> ##D     width = 0.2, position = pg
> ##D   ) +
> ##D   geom_point(position = pg) +
> ##D   geom_line(
> ##D     data = gbm_t$tune_performance,
> ##D     aes(as.numeric(factor(n.minobsinnode)),
> ##D       TSS_mean,
> ##D       col = factor(shrinkage)
> ##D     ), position = pg
> ##D   ) +
> ##D   facet_wrap(. ~ n.trees) +
> ##D   theme(legend.position = "bottom")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("tune_net")
> ### * tune_net
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tune_net
> ### Title: Fit and validate Neural Networks models with exploration of
> ###   hyper-parameters
> ### Aliases: tune_net
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(abies_db)
> ##D abies_db
> ##D 
> ##D # We will partition the data with the k-fold method
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D 
> ##D # pr_ab columns is species presence and absences (i.e. the response variable)
> ##D # from aet to landform are the predictors variables (landform is a qualitative variable)
> ##D 
> ##D # Hyper-parameter values for tuning
> ##D tune_grid <-
> ##D   expand.grid(
> ##D     size = c(2, 4, 6, 8, 10),
> ##D     decay = c(0.001, 0.05, 0.1, 1, 3, 4, 5, 10)
> ##D   )
> ##D 
> ##D net_t <-
> ##D   tune_net(
> ##D     data = abies_db2,
> ##D     response = "pr_ab",
> ##D     predictors = c(
> ##D       "aet", "cwd", "tmin", "ppt_djf",
> ##D       "ppt_jja", "pH", "awc", "depth", "percent_clay"
> ##D     ),
> ##D     predictors_f = c("landform"),
> ##D     partition = ".part",
> ##D     grid = tune_grid,
> ##D     thr = "max_sens_spec",
> ##D     metric = "TSS",
> ##D   )
> ##D 
> ##D # Outputs
> ##D net_t$model
> ##D net_t$predictors
> ##D net_t$performance
> ##D net_t$hyper_performance
> ##D net_t$data_ens
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("tune_raf")
> ### * tune_raf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tune_raf
> ### Title: Fit and validate Random Forest models with exploration of
> ###   hyper-parameters
> ### Aliases: tune_raf
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(abies_db)
> ##D abies_db
> ##D 
> ##D # We will partition the data with the k-fold method
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D 
> ##D tune_grid <-
> ##D   expand.grid(mtry = seq(1, 7, 1))
> ##D 
> ##D rf_t <-
> ##D   tune_raf(
> ##D     data = abies_db2,
> ##D     response = "pr_ab",
> ##D     predictors = c(
> ##D       "aet", "cwd", "tmin", "ppt_djf",
> ##D       "ppt_jja", "pH", "awc", "depth", "percent_clay"
> ##D     ),
> ##D     predictors_f = c("landform"),
> ##D     partition = ".part",
> ##D     grid = tune_grid,
> ##D     thr = "max_sens_spec",
> ##D     metric = "TSS",
> ##D   )
> ##D 
> ##D # Outputs
> ##D rf_t$model
> ##D rf_t$predictors
> ##D rf_t$performance
> ##D rf_t$hyper_performance
> ##D rf_t$data_ens
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("tune_svm")
> ### * tune_svm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tune_svm
> ### Title: Fit and validate Support Vector Machine models with exploration
> ###   of hyper-parameters
> ### Aliases: tune_svm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(abies_db)
> ##D abies_db
> ##D 
> ##D # We will partition the data with the k-fold method
> ##D 
> ##D abies_db2 <- part_random(
> ##D   data = abies_db,
> ##D   pr_ab = "pr_ab",
> ##D   method = c(method = "kfold", folds = 5)
> ##D )
> ##D 
> ##D # pr_ab columns is species presence and absences (i.e. the response variable)
> ##D # from aet to landform are the predictors variables (landform is a qualitative variable)
> ##D 
> ##D # Hyper-parameter values for tuning
> ##D tune_grid <-
> ##D   expand.grid(
> ##D     C = c(2, 4, 8, 16, 20),
> ##D     sigma = c(0.01, 0.1, 0.2, 0.3, 0.4)
> ##D   )
> ##D 
> ##D svm_t <-
> ##D   tune_svm(
> ##D     data = abies_db2,
> ##D     response = "pr_ab",
> ##D     predictors = c(
> ##D       "aet", "cwd", "tmin", "ppt_djf",
> ##D       "ppt_jja", "pH", "awc", "depth", "percent_clay"
> ##D     ),
> ##D     predictors_f = c("landform"),
> ##D     partition = ".part",
> ##D     grid = tune_grid,
> ##D     thr = "max_sens_spec",
> ##D     metric = "TSS",
> ##D   )
> ##D 
> ##D # Outputs
> ##D svm_t$model
> ##D svm_t$predictors
> ##D svm_t$performance
> ##D svm_t$hyper_performance
> ##D svm_t$data_ens
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.66 0.66 7.47 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
